# 주소 개방법(Open Addressing)
- 해시 테이블에서 충돌을 해결하는 또 하나의 방법
- 모든 키-값 쌍을 해시 테이블 배열 내에 직접 저장. 충돌이 발생하면 다른 빈 슬롯을 찾아 데이터를 저장
- 특징
    - 모든 데이터가 해시 테이블 배열 내에 저장
    - 별도의 체인이나 추가 데이터 구조가 필요 없음
- 충돌이 발생했을 경우, 빈 슬롯을 찾는 여러 가지 방법이 있음
    - 선형 탐사(Linear Probing)
    - 제곱 탐사(Quadratic Probing)
    - 이중 해싱(Double Hashing)

# 선형 탐사
- 해시 충돌을 해결하는 간단하면서도 효과적인 방법
- 충돌이 발생했을 때, 순차적으로 다음 버킷을 검사하여 빈 슬롯을 찾는 방식
- 작동원리
    1. 해시 함수로 초기 버킷 위치를 계산
    2. 해당 버킷이 이미 사용중이라면, 다음 버킷으로 이동
    3. 빈 버킷을 찾을 때까지 위 과정을 반복

# 선형 탐사 정리
- 장점
    - 구현이 간단
    - 캐시 성능이 좋음(연속된 메모리를 사용하기 때문)
    - 추가 메모리가 필요 없음(정해진 테이블 내에 저장하기 때문)
- 단점
    - 클러스터링 문제 : 연속된 항목들이 몰리는 현상이 발생할 수 있음
    - 테이블이 거의 가득 찼을 때 성능이 크게 저하
    - 최악의 경우 검색이 O(N)
- 테이블의 효율성을 위해 로드 팩터가 특정 임계값(0.6~0.75)을 초과하면 테이블 크기를 늘리고, 모든 항목을 재삽입(로드 팩터: 해시 테이블에 저장된 항목의 수를 테이블 크기로 나눈 값. 성능을 나타내는 중요한 지표)

# 제곱 탐사
- 해시 충돌을 해결하는 방법 중 선형 탐사의 단점을 보완하기 위해 고안된 방법
- 충돌이 발생했을 때, 원래의 해시 값에서 제곱수만큼 떨어진 위치를 순차적으로 탐색
- 작동원리
    1. 해시 함수로 초기 버킷 위치를 계산
    2. 해당 버킷이 이미 사용중이라면, 1<sup>2</sup>, 2<sup>2</sup>, 3<sup>2</sup>, 4<sup>2</sup>,... 만큼 떨어진 위치를 순차적으로 확인
    3. 빈 버킷을 찾을 때까지 위 과정을 반복
- 장점
    - 선형 탐사에 비해 클러스터링 문제가 덜함
    - 충돌 해결을 더 넓은 범위로 함으로 충돌 해결 능력이 조금 더 향상됨
    - 캐시 성능이 좋음(연속된 메모리)
- 단점
    - 이차 클러스터링이 발생 할 수 있음(충돌 해결 과정에서 동일한 탐사 순서를 따르는 현상)
    - 테이블이 절반 이상 차면 성능이 급격히 저하될 수 있음
    - 모든 버킷을 탐색하지 못할 수도 있음 (순환 패턴으로 인해) -> 테이블 크기를 소수로 선택하면 모든 버킷 탐색
- 이중 해싱과의 결합, 동적 해시를 통해 성능을 개선 할 수 있음

# 이중 해싱
- 두 개의 해시 함수를 사용하여 충돌을 해결
- 첫번째 함수는 초기 위치를 결정하고, 두 번째 해시 함수는 충돌 시 탐사 간격을 결정
- 작동원리
    1. 첫 번째 해시 함수(h1)로 초기 버킷 위치를 계산
    2. 해당 버킷이 이미 사용중이라면, 두 번째 해시 함수(h2)로 탐사 간격을 계산
    3. 해당 간격으로 다음 위치를 탐색
    4. 빈 버킷을 찾을 때까지 위 과정을 반복
- 장점
    - 클러스러링 문제를 크게 감소시킴
    - 선형 탐사나 제곱 탐사보다 더 균일한 분포를 제공
    - 두 번째 해시 함수로 인해 충돌 해결 패턴이 다양함
- 단점
    - 두 개의 해시 함수를 계산해야 하므로 약간의 추가 연산이 필요함
    - 구현이 조금 더 복잡함
    - 두 번째 해시 함수를 잘 못 선택하면 성능이 저하 될 수 있음
